package org.firstinspires.ftc.teamcode.ftc2017to2018season.TeleOp;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;


/**
 * Created by Pahel and Rohan on 11/18/17.
 */


@TeleOp(name = "Delta_TeleOp_2")
//@Disabled
public class Delta_TeleOp_2 extends OpMode {
/*Delta_TeleOp is designed for and tested with the Tile Runner robot. If this program is used with another robot it may not worked.
* This is specificly made for the Tile Runner and not another pushbot or competiotion robot. However, this program is the basic design for
* simple program and could work on a different robot with simple debugging and configuration.*/

    /*
        ---------------------------------------------------------------------------------------------

       Define the actuators we use in the robot here
    */
    to declare = to tell the program what is on the robot

    DcMotor leftWheelMotorFront;
    DcMotor leftWheelMotorBack;
    DcMotor rightWheelMotorFront;
    DcMotor rightWheelMotorBack;
    These four motors are the ones used for movement and they are declared here

    DcMotor slideMotor;
    This is the motor used to move the linear slide carrying the glyph manipulator which is declared here

    Servo glyphServoRight;
    Servo glyphServoLeft;
    These two servos are used to open and close the glyph manipulator

    Initial value for slide motor. This is used further down in the program for incremental movement.
    public int IVFSM;

    @Override
    public void init() {
        leftWheelMotorFront = hardwareMap.dcMotor.get("leftWheelMotorFront");
        leftWheelMotorBack = hardwareMap.dcMotor.get("leftWheelMotorBack");
        rightWheelMotorFront = hardwareMap.dcMotor.get("rightWheelMotorFront");
        rightWheelMotorBack = hardwareMap.dcMotor.get("rightWheelMotorBack");
        In this we tell the program or Android Studios that the things we named above are peices of harware on the robot.
        These four wheels are the ones used for movement.

        glyphServoRight = hardwareMap.servo.get("glyphServoRight");
        glyphServoLeft = hardwareMap.servo.get("glyphServoLeft");
        In this we tell the program or Android Studios that the things we named above are peices of harware on the robot.
        These are the servos used for opening and closing the claw

        slideMotor = hardwareMap.dcMotor.get("slideMotor");
        In this we tell the program or Android Studios that the things we named above are peices of harware on the robot.
        This is the motor used for the linear slides attached to the glyph manipulator

        IVFSM = slideMotor.getCurrentPosition();
        In this we define what the variable we created above is valued at.



        rightWheelMotorFront.setDirection(DcMotor.Direction.REVERSE);
        rightWheelMotorBack.setDirection(DcMotor.Direction.REVERSE);
        In the mechanical design of the robot the right wheels turn the opposite direction than the left wheels when the same power value is given to them
        We reverse the right wheels to avoid confusion later in the program


        glyphServoLeft.setPosition(0.5);
        glyphServoRight.setPosition(0.35);
        Here we set the glyph manipulator to the open position by moving a servo to the shown values.
        Servos are moved by setting a value to them ranging from 1-0. You have to guess and check with servos.





    }

    @Override
    public void loop() {
    This public void or loop() is what runs after the init is completed and the play button is selected.
    This is an automatic part of TeleOp program
        FourWheelDrive();
        slideMove();
        glyphManipulator();
        slideIncrement();
        These are functions or different sets of instructions that all control different parts of the robot.
        Functions are used to keep a program organized.


    }


    Functions go here
 */

    public void FourWheelDrive() {
        /*

        read the gamepad values and put them into variables
         */
        float leftY_gp1 = (-gamepad1.left_stick_y);
        float rightY_gp1 = (-gamepad1.right_stick_y);
     floats are decimals but less precise. A precise decimal is a double. A less precise decimal is a float
     the gamepad1.left/right_stick_y are the values of the joysticks on the gamepads on the y axis or up and down.

        if (gamepad1.left_trigger > 0) {
        Here we say if the left trigger is hit strafe to the left by setting power to the motors to turn the mecanum wheels in the right way.

            leftWheelMotorFront.setPower(-1);
            leftWheelMotorBack.setPower(1);
            rightWheelMotorFront.setPower(1);
            rightWheelMotorBack.setPower(-1);

        } else if (gamepad1.right_trigger > 0) {
        Here we say if the right trigger is hit strafe to the right by setting power to the motors to turn the mecanum wheels in the right way.
            leftWheelMotorFront.setPower(1);
            leftWheelMotorBack.setPower(-1);
            rightWheelMotorFront.setPower(-1);
            rightWheelMotorBack.setPower(1);

        } else {
        Otherwise we put the robot in tank drive where we say if the left joystcik is pushed up or down move the left wheels forward or backward.
        The same goes for the right wheels.
            leftWheelMotorFront.setPower(leftY_gp1);
            leftWheelMotorBack.setPower(leftY_gp1);
            rightWheelMotorFront.setPower(rightY_gp1);
            rightWheelMotorBack.setPower(rightY_gp1);
        }



    }

    public void slideMove() {

        slideMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        IVFSM = slideMotor.getCurrentPosition();

        if (gamepad2.right_stick_y != 0) {
        Here we say if on the second gamepad the right stick isn't equal to 0 move the linear slides proportionally to the amount of movement
        on the joystick.

            slideMotor.setPower(gamepad2.right_stick_y);

        }
    }

    public void glyphManipulator() {


        if (gamepad1.left_bumper) {

//opening the claw
            glyphServoRight.setPosition(0.35);

            glyphServoLeft.setPosition(0.5);
        } else if (gamepad1.right_bumper) {

            glyphServoRight.setPosition(0.05);

            glyphServoLeft.setPosition(0.85);

           /* telemetry.addData("The value of the right servo is", glyphServoRight.getPosition());
            telemetry.addData("The value of the left servo is", glyphServoLeft.getPosition());
            telemetry.update();    */
        }

/*        telemetry.addData("The value of the right servo is", left_claw);
        telemetry.addData("The value of the left servo is", right_claw);
        telemetry.update();

        */
    }

    public void slideIncrement() {

       /* if (gamepad2.dpad_down)
        {

            moveUpInch(2.54);

        }*/
    if (gamepad2.dpad_up)
        {
            moveUpInch(-2.54);
        }
        else {

        }
    }

   /*  public void moveUpInch(double cm) {
        double target_Position;
        double countsPerCM = 609.6;
        double finalTarget = cm*countsPerCM;
        target_Position = slideMotor.getCurrentPosition() + finalTarget;


        slideMotor.setTargetPosition((int)target_Position);

        slideMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        slideMotor.setPower(-0.6);

        while (slideMotor.isBusy()){
            telemetry.addData("In while loop in moveUpInch", slideMotor.getCurrentPosition());
            telemetry.update();

        }

        slideMotor.setPower(0);

    }*/

   public void moveUpInch(double cm) {
        double target_Position;
        double countsPerCM = 609.6;
        double finalTarget = cm*countsPerCM;
        target_Position = slideMotor.getCurrentPosition() + finalTarget;


        slideMotor.setTargetPosition((int)target_Position);

        slideMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        slideMotor.setPower(-0.6);

        while (slideMotor.isBusy()){
            telemetry.addData("In while loop in moveDownInch", slideMotor.getCurrentPosition());
            telemetry.update();

        }

        slideMotor.setPower(0);

    }


}

//--------------------------------------------------------------------------------------------